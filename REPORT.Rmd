---
title: "Sea Around Us Project"
author: "Leonie Grau, Felix Rentschler, Victoria Kolodziej"
date: "March 6, 2018"
output: html_document
runtime: shiny
---

# Introduction

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(shiny)
library(ggplot2)
library(tidyverse)
```
The Sea Around Us initiative is a research project by the University of British Columbia, that offers reconstructed catch data for worldwide fisheries and fishery resources. Since overfishing is the major driver on the declining viability of fish stocks, a monitoring program with valid data is crucial for evaluating the marine development. The database provides information for policy makers, fishery managers and the scientific community to get a better understanding of global fishery catches and more detailed information about which countries are involved.  The impact of fishery on the marine ecosystems therefore is presented on a spatial scale in such a way that it has an ecological and political relevance. <cite>(Pauly D. and Zeller D. , 2015. Sea Around Us Concepts, Design and Data<cite> [www.seaaroundus.org](www.seaaroundus.org))

The database covers catch data over 64 years (1950-2014), 4 fishing sectors (industrial, artisanal, subsistence and recreational), 2 catch types (landed and discarded catch) and 2 types of reporting status (reported and unreported). There are 5 regions that can be shown: Exclusive-economic zones (EEZ), large marine ecosystems (LME), regional fisheries management organizations (RFMO),  EEZ-bordering and taxon. [...]

For the purpose of a more in depth data work the R library “seaaroundus” is provided. The aim of this project is create an interactive web app to present specific data from the sea around us database. This is realised by the use of  the R package “shiny”. 

The aim of this project is to get relevant information from the database in order to show worldwide catch on the one hand and to visualise this information in an interactive way on the other hand.


# Materials and Methods

The basis for this project is the seaaroundus-R-package providing functions to access the seaaroundus database. The main function to get specific data is the `catchdata`-function which transfers the input arguments to the database and returns either a data frame or a plot. Input arguments specify the spatial dimension (`region`, `id`) as well as the type of data (`measure`, `dimension`), i.e. how it is quantified and what attributes are presented. The arguments `limit`, `chart` and `...` refer to how the data is returned.

```{r}
seaaroundus::catchdata
```

Since the `catchdata`-function does not provide the option to get information for more than one `id` at once, a loop was run on the function passing a vector with all required ids in order to get overall information stored in one `data.frame`. This was done to get information on 

* the total catch for each country (`region="fishing-entity"` and `dimension="country"`)
* the amount of landings and discards for each country (`region="fishing-entity"` and `dimension="catchtype"`)
* the total catch within all Exclusive Economic Zones (EEZ) being the sum of discards and landings (`region="eez"` and `dimension="catchtype"`)
* the amount of catch wihtin all EEZs taken by which country limited to the top 5 (`region="eez"`, `dimension="country"` and `limit=5`)

For all queries `measure` was set to `"tonnage"`. Below an exemplary code is shown: 

```{r, eval=F, echo=T}
# ---- Query catchtype-data for each country ----

# loop over catchdata with all countryids; output as list
list_cd <- lapply(X = countryids, FUN = catchdata, region="fishing-entity", measure="tonnage", dimension="catchtype")

# for further processing the data has to be extracted from the list and put into one data.frame: ----

# initial data.frame to be filled with remaining list entries
df_cd <- list_cd[[1]]
df_cd$country <- countrynames[1]

# loop to get all entries of list into one data.frame
for (i in 2:length(list_cd)){
  
  df_new <- list_cd[[i]]
  
  if (ncol(df_new)<3)   # if clause to check for same amount of columns
    df_new$discards <- 0
  
  df_new$country <- countrynames[i]
  
  df_cd <- bind_rows(df_cd, df_new)
}

```


In order to visualise the queried data _R-Shiny Web App_ was used. This allows an interactive display of the information gathered on global fish catch. In general, the data is shown in a graph as well as in a table, both reacting to different dynamic input variables which the user is able to modify according to his or her interests. 

The implemented shiny app consists of two parts which need to be defined: 
`shinyApp(ui, server)` 
In the first one, the user interface is specified. Here, the layout contains a `sidebarPanel` and a `MainPanel` where input and ouput variables are arranged. The input variables build the interactive part providing a set of choices towards the ouput: three `select`-options and one `slider`-option give the possibility to change 

* the information which shall be displayed (*total catch* or _proportion of discards_)
* the time span for which the information shall be displayed (ranging from 1950 to 2014)
* the number of countries for which the information shall be displayed in the plots (ranging from 1 to 12 with default 6)
* the number of entries to be listed in the tables (giving 5 choices)

The `MainPanel` defines the arrangement of the output in Tabs, i.e. showing either the plot *or* the table.

```{r, eval=F, echo=T}
#read in data: ----
df_fishing_all <- source("df_fishing_all.Rdmpd")
df_fishing_all <- df_fishing_all[[1]]
df_Q2 <- read.delim("df_Q2")

# Define UI for seaaroundus app ----
ui <- fluidPage(
  
  # App title ----
  titlePanel("seaaroundus"),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    
    # Sidebar panel for inputs ----
    sidebarPanel(
      
      # Input: Select-option for type of information in plots ----
      selectInput(inputId = "dim",
                  label = "Select type",
                  choices = c("total catch", "discards")),
      
      # Input: Slider for range of years to be displayed ----
      sliderInput(inputId = "range",
                  label = "Select time span",
                  min = 1950,
                  max = 2014,
                  sep = "",
                  value = c(1950, 2014)),
      
      # Input: Select-option for number of countries to be displayed in plots
      selectInput(inputId = "number",
                  label = "Select number of countries in Graph",
                  choices = c(1:12),
                  selected = 6),
      
      # Input: Select-option for number of entries to be listed in tables
      radioButtons(inputId = "table_len",
                   label = "Select number of entries in Table",
                   inline=T,
                   choiceNames = c("5", "10", "15", "20", "all"),
                   choiceValues = c(5, 10, 15, 20, 197))
    ),
    
    # Main panel for outputs ----
    mainPanel(
      
      # Output: Two tab panels: ----
      tabsetPanel(type="tabs",
                  tabPanel("Graph", plotOutput(outputId = "areaPlot")),
                  tabPanel("Table", tableOutput("values"))
      )
    )
  )
)
```

In the second part of the shiny app the server is defined, being the part which reacts to the varying input variables and which compiles the output. First, two reactive functions, `dataInput` and `calcTable`, return the changing data which are needed to produce the outputs:

```{r, eval=F, echo=T}
# Define server required to draw plots and show tables ----
server <- function(input, output) {
  
  # First reactive function returning basis for plots and tables (output 1 and 2)
  dataInput <- reactive({
    
    data <- switch(input$dim,
                   "total catch" = df_fishing_all,
                   "discards" = df_Q2)
    
    range <- input$range
    
    number <- input$number
    
    data_plot <- data %>% filter(years>=range[1], years<=range[2])
    
    if(input$dim == "total catch"){
      data_table <- data_plot %>% gather(., key="country", value="tonnage", -c(years)) %>%
        group_by(country) %>% summarise(avg=sum(tonnage))
    }
    else {
      data_table <- data %>%
        mutate(perc_disc = (discards/(landings+discards))*100) %>% 
        group_by(country) %>% summarise(avg=mean(perc_disc))
    }
    
    return(list("data_plot"=data_plot, "data_table" = data_table, "number"=number))
  })
  
  # Second reactive expression returning values for tables (output 2) ----
  calcTable <- reactive({
    
    data_table <- dataInput()$data_table
    
    if(input$dim=="total catch"){
      data_table <- arrange(data_table, desc(avg))[c(1:input$table_len),]
      colnames(data_table) <- c("country", "sum of catches in tons")
    }
    else{
      data_table <- arrange(data_table, desc(avg))[c(1:input$table_len),]
      colnames(data_table) <- c("country", "average discards in %")
    }
    
    return(data_table)
  })
```

Then, both outputs, plot and table, are created. Therefore, the returned changed input data is further processed for the `output$areaPlot` via an `if else` statement and plotting commands using `ggplot()`. The `output$values` to create the table is getting passed the return of the `calcTable`-function. The Shiny App is run via the command `shinyApp(ui = ui, server = server)`.

```{r, eval=F, echo=T}
# Output 1: Plots ----
  output$areaPlot <- renderPlot({
    
    data <- dataInput()$data_plot
    number <- as.integer(dataInput()$number)
    
    if (input$dim == "total catch"){
      
      data <- data %>% gather(., key="country", value="tonnage", -c(years)) 
      
      data_arranged <- data %>% group_by(country) %>% summarise(avg=mean(tonnage)) %>% arrange(., desc(avg))
      
      data_high <- data %>% filter(country %in% data_arranged[c(1:number),]$country)
      data_low <- data %>% filter(country %in% data_arranged[c((number +1):nrow(data)),]$country)  %>% group_by(years) %>%
        summarise(tonnage = sum(tonnage)) %>% mutate(country = "Others") %>%
        select(years,country,tonnage)
      
      
      data <- bind_rows(data_high, data_low)
      
      ggplot(data=data, aes(x= years, y=tonnage))+
        geom_area(aes(fill=factor(country, levels=c(data_arranged[c(1:number),]$country, "Others"))))+
        theme(legend.position = "right")+
        guides(fill=guide_legend(title="countries"))+
        labs(title = "Total catch")
    }
    else {
      data <- data %>%
        mutate(perc_disc = (discards/(landings+discards))*100)
      data1 <- data %>%
        group_by(country) %>%
        summarise(avg=mean(perc_disc)) %>%
        arrange(., desc(avg)) %>% 
        top_n(., n=number)
      
      data_high <- data %>% filter(country %in% data1$country)
      
      ggplot(data=data_high, aes(x=years, y=perc_disc, colour=country))+
        geom_line(size=1.3)+
        theme(legend.position = "right")+
        labs(title = "Share of discards in total catch", y = "percentage")
    }
  })
  
  # Output 2: Table ----
  output$values <- renderTable({
    calcTable()
  })
  
}

# Create Shiny app ----
shinyApp(ui = ui, server = server)
```


# Results

## seaaroundus - Shiny Web App

```{r tabsets, echo=FALSE}

#read in data: ----
df_fishing_all <- source("df_fishing_all.Rdmpd")
df_fishing_all <- df_fishing_all[[1]]
df_Q2 <- read.delim("df_Q2")

# Define UI for seaaroundus app ----
ui <- fluidPage(
  
  # App title ----
  titlePanel("seaaroundus"),
  
  # Sidebar layout with input and output definitions ----
  sidebarLayout(
    
    # Sidebar panel for inputs ----
    sidebarPanel(
      
      # Input: Select-option for type of information in plots ----
      selectInput(inputId = "dim",
                  label = "Select type",
                  choices = c("total catch", "discards")),
      
      # Input: Slider for range of years to be displayed ----
      sliderInput(inputId = "range",
                  label = "Select time span",
                  min = 1950,
                  max = 2014,
                  sep = "",
                  value = c(1950, 2014)),
      
      # Input: Select-option for number of countries to be displayed in plots
      selectInput(inputId = "number",
                  label = "Select number of countries in Graph",
                  choices = c(1:12),
                  selected = 6),
      
      # Input: Select-option for number of entries to be listed in tables
      radioButtons(inputId = "table_len",
                   label = "Select number of entries in Table",
                   inline=T,
                   choiceNames = c("5", "10", "15", "20", "all"),
                   choiceValues = c(5, 10, 15, 20, 197))
    ),
    
    # Main panel for displaying outputs with options ----
    mainPanel(
      
      # Output: Two tab panels: ----
      tabsetPanel(type="tabs",
                  tabPanel("Graph", plotOutput(outputId = "areaPlot")),
                  tabPanel("Table", tableOutput("values"))
      )
    )
  )
)


# Define server logic required to draw plots and show tables ----
server <- function(input, output) {
  
  # First reactive function returning basis for plots and tables (output 1 and 2)
  dataInput <- reactive({
    
    data <- switch(input$dim,
                   "total catch" = df_fishing_all,
                   "discards" = df_Q2)
    
    range <- input$range
    
    number <- input$number
    
    data_plot <- data %>% filter(years>=range[1], years<=range[2])
    
    if(input$dim == "total catch"){
      data_table <- data_plot %>% gather(., key="country", value="tonnage", -c(years)) %>%
        group_by(country) %>% summarise(avg=sum(tonnage))
    }
    else {
      data_table <- data %>%
        mutate(perc_disc = (discards/(landings+discards))*100) %>% 
        group_by(country) %>% summarise(avg=mean(perc_disc))
    }
    
    return(list("data_plot"=data_plot, "data_table" = data_table, "number"=number))
  })
  
  # Second reactive expression returning values for tables (output 2) ----
  calcTable <- reactive({
    
    data_table <- dataInput()$data_table
    
    if(input$dim=="total catch"){
      data_table <- arrange(data_table, desc(avg))[c(1:input$table_len),]
      colnames(data_table) <- c("country", "average catch per year in tons")
    }
    else{
      data_table <- arrange(data_table, desc(avg))[c(1:input$table_len),]
      colnames(data_table) <- c("country", "share of discards in average catch per year in %")
    }
    
    return(data_table)
  })
  
  
  # Output 1: Plots ----
  output$areaPlot <- renderPlot({
    
    data <- dataInput()$data_plot
    number <- as.integer(dataInput()$number)
    
    if (input$dim == "total catch"){
      
      data <- data %>% gather(., key="country", value="tonnage", -c(years)) 
      
      data_arranged <- data %>% group_by(country) %>% summarise(avg=mean(tonnage)) %>% arrange(., desc(avg))
      
      data_high <- data %>% filter(country %in% data_arranged[c(1:number),]$country)
      data_low <- data %>% filter(country %in% data_arranged[c((number +1):nrow(data)),]$country)  %>% group_by(years) %>%
        summarise(tonnage = sum(tonnage)) %>% mutate(country = "Others") %>%
        select(years,country,tonnage)
      
      
      data <- bind_rows(data_high, data_low)
      
      ggplot(data=data, aes(x= years, y=tonnage))+
        geom_area(aes(fill=factor(country, levels=c(data_arranged[c(1:number),]$country, "Others"))))+
        theme(legend.position = "right")+
        guides(fill=guide_legend(title="countries"))+
        labs(title = "Total catch")
    }
    else {
      data <- data %>%
        mutate(perc_disc = (discards/(landings+discards))*100)
      data1 <- data %>%
        group_by(country) %>%
        summarise(avg=mean(perc_disc)) %>%
        arrange(., desc(avg)) %>% 
        top_n(., n=number)
      
      data_high <- data %>% filter(country %in% data1$country)
      
      ggplot(data=data_high, aes(x=years, y=perc_disc, colour=country))+
        geom_line(size=1.3)+
        theme(legend.position = "right")+
        labs(title = "Share of discards in total catch", y = "percentage")
    }
  })
  
  # Output 2: Table ----
  output$values <- renderTable({
    calcTable()
  })
}

# Create Shiny app ----
shinyApp(ui = ui, server = server)
```

The `total catch` - plot shows the average amount of catch per year in tonnage over time as a stacked chart for up to 12 countries which are ordered descendingly by amount of catch. The remaining countries are summarised as "Others" for each chosen number of countries. The default settings display 6 countries for the whole time period from 1950 to 2014, showing Japan to be the country with the highest average catch during this time span followed by the Russian Federation, Peru, USA, China and Norway. The table output provides the same information in numbers but offers to return the data for 5, 10, 15, 20 or all countries, which in total is 197. The default here is set to 5 countries.


